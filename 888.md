# 数据源分析与优化建议

本文档详细分析了当前前端各模块的数据获取方式（RPC vs Indexer），并针对性能瓶颈提出了具体的优化建议。

## 一、 数据源概览

目前系统采用 **混合数据架构**：
*   **实时性要求高的数据**（如余额、当前轮次状态）：直接通过 **RPC (Web3 Provider)** 读取链上合约。
*   **列表/历史数据**（如订单历史、团队列表）：通过 **Ponder Indexer (GraphQL)** 获取。
*   **混合验证模式**：部分场景先从 Indexer 获取列表，再通过 RPC Multicall 验证实时状态（如订单队列）。

---

## 二、 各模块详细分析

### 1. 交易模块 (Exchange)
**文件路径**: `frontend/src/hooks/useExchangeData.ts`

| 数据内容 | 获取方式 | 详情 |
| :--- | :--- | :--- |
| **用户余额** | 🔵 RPC | 直接调用 `USDT.balanceOf` 和 `ALI.balanceOf`。 |
| **市场统计** | 🔵 RPC | 调用 `Exchange.getQueueLength/Volume` 获取买卖盘深度。 |
| **用户当前挂单** | 🟡 混合 | 1. **Indexer**: 获取 `Open` 状态订单列表。<br>2. **RPC (Multicall)**: 批量验证订单实时状态（是否成交/取消），修正 Indexer 延迟。 |
| **市场队列 (Queue)** | 🟡 混合 | 1. **Indexer**: 获取队列 ID 列表。<br>2. **RPC (Multicall)**: 验证前 50 个订单的有效性，计算真实排名。 |
| **历史订单/成交** | 🟣 Indexer | 完全依赖 Subgraph 查询 `exchangeOrders` 和 `exchangeTrades`。 |

### 2. 奖池模块 (Jackpot/Earn)
**文件路径**: `frontend/src/hooks/useJackpotData.ts`

| 数据内容 | 获取方式 | 详情 |
| :--- | :--- | :--- |
| **当前轮次信息** | 🔵 RPC | 调用 `fomoStartTime`, `currentDayIndex`, `getDailyRoundDetails`。 |
| **倒计时/时间** | 🔵 RPC | 基于链上时间戳计算。 |
| **用户本轮投入** | 🔵 RPC | 调用 `getUserCurrentRoundStats`。 |
| **Top 3 榜单** | 🔵 RPC | 直接从 `getDailyRoundDetails` 返回结果中解析。 |

### 3. 邀请返佣 (Referral)
**文件路径**: `frontend/src/hooks/useReferralData.ts`

| 数据内容 | 获取方式 | 详情 |
| :--- | :--- | :--- |
| **用户基础数据** | 🔵 RPC | 批量调用 `getUserProfile`, `userRewards`, `getUserInvestmentInfo` 等。 |
| **分红池权重** | 🔴 RPC (慢) | **高风险**: 使用 `protocol.queryFilter` 遍历 `ReferralWeightUpdated` 事件日志来计算用户权重。随着区块增加，此操作会越来越慢甚至超时。 |
| **待领取奖励** | 🔵 RPC | 实时计算各类型待领取奖励。 |

### 4. 团队伙伴 (Partners)
**文件路径**: `frontend/src/hooks/usePartnersData.ts`
**问题**: 存在 N+1 查询性能瓶颈。

| 数据内容 | 获取方式 | 详情 |
| :--- | :--- | :--- |
| **直推列表** | 🟣 Indexer | 查询 `users(where: { sponsor: ... })` 获取下级列表。 |
| **伙伴详细数据** | 🔴 RPC (重) | **N+1 问题**: 先拿到 N 个下级用户，再发起 N 组 Multicall 请求查询每个人的详细业绩。用户量大时会导致请求过大。 |
| **FOMO 获奖历史** | 🟣 Indexer | 查询 `fomoWinners` 实体。 |
| **奖励领取记录** | 🟣 Indexer | 查询 `rewardClaims` 实体。 |

---

## 三、 优化建议 (Optimization Roadmap)

### 🔴 高优先级 (High Priority)

#### 1. 移除 `useReferralData` 中的事件遍历
*   **当前问题**: `queryFilter` 遍历事件日志在前端执行非常低效，且受限于 RPC 节点返回限制（通常限制 2000-5000 区块范围）。
*   **优化方案**:
    *   在 **Indexer** 中处理 `ReferralWeightUpdated` 事件，将用户的 `currentWeight` 聚合存储在 `User` 实体中。
    *   前端直接查询 GraphQL 获取权重，替代 RPC 事件查询。

#### 2. 优化 `usePartnersData` 的 N+1 查询
*   **当前问题**: 如果用户有 100 个直推，前端会发起包含 300 个调用的 Multicall，容易失败或阻塞。
*   **优化方案**:
    *   将 `activeInvestmentsTotal`, `teamActiveVolume`, `leadershipRank` 等字段直接同步到 Indexer 的 `User` 实体。
    *   前端只需一次 GraphQL 查询即可拿到所有展示数据，完全移除此处的 RPC Multicall。

### 🟡 中优先级 (Medium Priority)

#### 3. 全局缓存 Token Decimals
*   **当前问题**: 几乎每个 Hook 都在重复获取 USDT 和 ALI 的 `decimals`。
*   **优化方案**:
    *   在 `Web3Provider` 或全局 Context 中获取一次并缓存，所有组件共享。

#### 4. 奖池历史记录
*   **当前问题**: 目前仅支持查看当前轮次。
*   **优化方案**:
    *   利用 Indexer 记录每一轮 (`FomoRound` 实体) 的详细数据（总奖池、Top3、中奖者）。
    *   前端可轻松实现“往期开奖记录”页面。

### 🟢 低优先级 (Low Priority)

#### 5. 市场队列深度图
*   **当前问题**: 仅验证前 50 个订单。
*   **优化方案**:
    *   如果需要展示完整的深度图，应完全依赖 Indexer 数据，并接受秒级的延迟，仅在用户点击“交易”时进行 RPC 实时检查。

---

## 四、 合约层优化建议 (Contract Layer Optimization)

针对上述前端遇到的性能瓶颈，建议在合约层进行以下优化，以提供更好的数据支持：

### 1. 增加批量视图函数 (Batch View Functions) ✅ 已完成
**解决 N+1 查询问题的根本方案。** 已在 `AlianaReferral` 和 `P2PExchangeFIFO` 合约中增加以下函数：

*   **`getBatchPartnerStats(address[] memory users)`**
    *   **状态**: ✅ 已实现
    *   **输入**: 用户地址列表。
    *   **输出**: 返回包含 `Rank`, `ActiveInvest`, `TeamSize`, `TeamVolume` 等字段的结构体数组。
    *   **收益**: 前端一次调用即可获取所有下级用户的详细数据，替代数百次 RPC 调用。

*   **`getOrdersBatch(uint256[] memory ids)`** (P2PExchange)
    *   **状态**: ✅ 已实现
    *   **输入**: 订单 ID 列表。
    *   **输出**: 返回 `Order` 结构体数组。
    *   **收益**: 简化前端 Multicall 逻辑，减少解码开销，提高数据一致性。

### 2. 暴露关键数据映射 (Expose Mappings) ✅ 已完成
**解决事件遍历过慢的问题。**

*   **`getUserDailyReferralWeight(uint256 dayIndex, address user)`**
    *   **状态**: ✅ 已实现 (AlianaFomo)
    *   **现状**: `referralWeights` 在 `DailyRound` 结构体中是 `mapping`，默认不可直接通过 `getDailyRoundDetails` 读取。
    *   **优化**: 已增加此 View 函数，直接返回 `dailyRounds[dayIndex].referralWeights[user]`。
    *   **收益**: 前端可直接读取用户当日权重，**完全移除** 低效的 `queryFilter` 事件遍历。

### 3. 存储空间优化 (Storage Packing) ✅ 已完成
**降低 Gas 消耗。**

*   **`UserProfile` 结构体优化**:
    *   **现状**: `address sponsor` (160 bits) -> `string username` (256 bits) -> `bool isRegistered` (8 bits)。
    *   **优化**: 将 `bool isRegistered` 移动到 `address sponsor` 之后。
    *   **结果**: `sponsor` 和 `isRegistered` 将打包在同一个 256-bit 插槽中 (160 + 8 = 168 < 256)，每次读取/写入可节省约 2000 Gas。

*   **`InvestmentPosition` 结构体优化**:
    *   **优化**: 将 `uint256 reinvestCount` 移前，让 `uint8 planType` 和 `bool isActive` 相邻。
    *   **结果**: 两个小变量共享同一个插槽，每个订单节省约 20,000 Gas。

